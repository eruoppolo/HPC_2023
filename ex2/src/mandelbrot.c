#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <omp.h>
#include <string.h>

// Function to compute iterations for a single point
int compute_mandelbrot(double cx, double cy, int max_iter) {
    double x = 0, y = 0;
    double x2 = 0, y2 = 0;
    int iter = 0;
    
    while (x2 + y2 <= 4 && iter < max_iter) {
        y = 2 * x * y + cy;
        x = x2 - y2 + cx;
        x2 = x * x;
        y2 = y * y;
        iter++;
    }
    
    return iter;
}

// Function to write PGM image using MPI I/O with error handling
int write_pgm_image_mpi(void *image, int maxval, int xsize, int ysize, 
                       const char *image_name, int rank, int size, int local_rows) {
    MPI_File file;
    MPI_Status status;
    int result;
    char header[1024];
    int header_size = 0;

    // Open file with error checking
    result = MPI_File_open(MPI_COMM_WORLD, image_name, 
                          MPI_MODE_CREATE | MPI_MODE_WRONLY, 
                          MPI_INFO_NULL, &file);
    if (result != MPI_SUCCESS) {
        char error_string[MPI_MAX_ERROR_STRING];
        int length_of_error_string;
        MPI_Error_string(result, error_string, &length_of_error_string);
        fprintf(stderr, "Error opening file on rank %d: %s\n", rank, error_string);
        return 0;
    }

    // Write header from rank 0
    if (rank == 0) {
        header_size = snprintf(header, sizeof(header), 
                             "P5\n# Generated by MPI\n%d %d\n%d\n", 
                             xsize, ysize, maxval);
        
        result = MPI_File_write(file, header, header_size, MPI_CHAR, &status);
        if (result != MPI_SUCCESS) {
            char error_string[MPI_MAX_ERROR_STRING];
            int length_of_error_string;
            MPI_Error_string(result, error_string, &length_of_error_string);
            fprintf(stderr, "Error writing header: %s\n", error_string);
            MPI_File_close(&file);
            return 0;
        }
    }

    // Broadcast header size to all processes
    MPI_Bcast(&header_size, 1, MPI_INT, 0, MPI_COMM_WORLD);
    
    // Synchronize after header write
    MPI_Barrier(MPI_COMM_WORLD);

    // Calculate offset for this process's data
    MPI_Offset offset = header_size + (MPI_Offset)(rank * local_rows * xsize);

    // Write process's portion of the image
    result = MPI_File_write_at(file, offset, image, local_rows * xsize, 
                              MPI_UNSIGNED_CHAR, &status);
    
    if (result != MPI_SUCCESS) {
        char error_string[MPI_MAX_ERROR_STRING];
        int length_of_error_string;
        MPI_Error_string(result, error_string, &length_of_error_string);
        fprintf(stderr, "Error writing data on rank %d: %s\n", rank, error_string);
        MPI_File_close(&file);
        return 0;
    }

    // Verify the number of elements written
    int elements_written;
    MPI_Get_count(&status, MPI_UNSIGNED_CHAR, &elements_written);
    if (elements_written != local_rows * xsize) {
        fprintf(stderr, "Warning: Rank %d wrote %d elements instead of %d\n",
                rank, elements_written, local_rows * xsize);
    }

    result = MPI_File_close(&file);
    if (result != MPI_SUCCESS) {
        char error_string[MPI_MAX_ERROR_STRING];
        int length_of_error_string;
        MPI_Error_string(result, error_string, &length_of_error_string);
        fprintf(stderr, "Error closing file on rank %d: %s\n", rank, error_string);
        return 0;
    }

    return 1;
}

int main(int argc, char** argv) {
    int provided;
    int rank, size;
    
    // Initialize MPI with thread support
    int init_result = MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &provided);
    if (init_result != MPI_SUCCESS) {
        fprintf(stderr, "Error initializing MPI\n");
        return 1;
    }
    
    if (provided < MPI_THREAD_FUNNELED) {
        fprintf(stderr, "Error: MPI implementation does not support MPI_THREAD_FUNNELED\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
        return 1;
    }

    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    
    if (argc != 9) {
        if (rank == 0) {
            fprintf(stderr, "Usage: %s nx ny x_left y_left x_right y_right max_iter num_threads\n", 
                    argv[0]);
        }
        MPI_Finalize();
        return 1;
    }
    
    // Parse command line arguments
    int nx = atoi(argv[1]);
    int ny = atoi(argv[2]);
    double x_left = atof(argv[3]);
    double y_left = atof(argv[4]);
    double x_right = atof(argv[5]);
    double y_right = atof(argv[6]);
    int max_iter = atoi(argv[7]);
    int num_threads = atoi(argv[8]);

    // Validate input parameters
    if (nx <= 0 || ny <= 0 || max_iter <= 0 || num_threads <= 0) {
        if (rank == 0) {
            fprintf(stderr, "Error: nx, ny, max_iter, and num_threads must all be positive integers.\n");
        }
        MPI_Finalize();
        return 1;
    }
    if (x_left >= x_right || y_left >= y_right) {
        if (rank == 0) {
            fprintf(stderr, "Error: x_left must be less than x_right and y_left must be less than y_right.\n");
        }
        MPI_Finalize();
        return 1;
    }

    // Set up OpenMP
    omp_set_dynamic(0);
    omp_set_num_threads(num_threads);

    // Start total timing
    MPI_Barrier(MPI_COMM_WORLD);
    double start_total = MPI_Wtime();

    // Calculate grid spacing
    double dx = (x_right - x_left) / nx;
    double dy = (y_right - y_left) / ny;
    
    // Calculate local work distribution
    int rows_per_process = ny / size;
    int remainder = ny % size;
    int start_row = rank * rows_per_process + (rank < remainder ? rank : remainder);
    int local_rows = rows_per_process + (rank < remainder ? 1 : 0);

    // Allocate memory for local image
    unsigned char* local_image = (unsigned char*)malloc(local_rows * nx);
    if (local_image == NULL) {
        fprintf(stderr, "Error: Unable to allocate memory for local image on rank %d.\n", rank);
        MPI_Abort(MPI_COMM_WORLD, 1);
        return 1;
    }
    
    MPI_Barrier(MPI_COMM_WORLD);  // Synchronize before starting compute

    // Start computation timing
    double start_compute = MPI_Wtime();
    
    // Compute Mandelbrot set
    #pragma omp parallel for schedule(dynamic)
    for (int j = 0; j < local_rows; j++) {
        for (int i = 0; i < nx; i++) {
            double cx = x_left + i * dx;
            double cy = y_left + (start_row + j) * dy;
            int iter = 255 - compute_mandelbrot(cx, cy, max_iter);
            local_image[j * nx + i] = (unsigned char)(iter == max_iter ? 1 : iter);
        }
    }
    
    MPI_Barrier(MPI_COMM_WORLD);  // Synchronize before starting compute

    // End computation timing
    double end_compute = MPI_Wtime();

    // Start I/O timing
    double start_io = MPI_Wtime();

    // Write the image file
    int write_success = write_pgm_image_mpi(local_image, max_iter, nx, ny, 
                                          "../plots/mandelbrot_mpi.pgm", 
                                          rank, size, local_rows);
    
    MPI_Barrier(MPI_COMM_WORLD);  // Synchronize before starting compute

    // End I/O timing
    double end_io = MPI_Wtime();

    // Calculate timings
    double compute_time = end_compute - start_compute;
    double io_time = end_io - start_io;
    double total_time = end_io - start_total;

    // Gather timing statistics
    double max_compute_time, max_io_time, max_total_time;
    
    MPI_Reduce(&compute_time, &max_compute_time, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);
    MPI_Reduce(&io_time, &max_io_time, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);
    MPI_Reduce(&total_time, &max_total_time, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);

    // Print timing information from rank 0
    if (rank == 0) {
        printf("Image size: %dx%d\n", nx, ny);
        printf("Number of processes: %d\n", size);
        printf("Threads per process: %d\n", num_threads);
        printf("Compute time: %f\n", max_compute_time);
        printf("I/O time: %f\n", max_io_time);
        printf("Total time: %f\n", max_total_time);
        printf("Pixels per process: %d\n", (nx * ny) / size);
        
        if (!write_success) {
            fprintf(stderr, "Warning: Image write operation failed\n");
        }
    }

    // Clean up
    free(local_image);
    
    // Ensure all processes are done before finalizing
    MPI_Barrier(MPI_COMM_WORLD);
    MPI_Finalize();
    
    return write_success ? 0 : 1;
}
